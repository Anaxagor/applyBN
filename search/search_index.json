{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api/bn_oversampling/","title":"Bayesian Network oversampling","text":"<p>               Bases: <code>BaseOverSampler</code></p> <p>Bayesian Network over-sampler.</p> Source code in <code>applybn/imbalanced/over_sampling/bn_over_sampler.py</code> <pre><code>class BNOverSampler(BaseOverSampler):\n    \"\"\"Bayesian Network over-sampler.\"\"\"\n\n    # TODO: Implement Bayesian Network over-sampler using BaseOverSampler as reference\n    # However, SamplerMixin, OneToOneFeatureMixin, BaseEstimator base classes from sklearn\n    # may be more appropriate\n    def __init__(self):\n        super().__init__()\n\n    def _fit_resample(self, X, y, **params):\n        pass\n</code></pre>"},{"location":"api/feature_extraction/","title":"Feature Extraction","text":""},{"location":"api/feature_extraction/#bnfeaturegenerator","title":"BNFeatureGenerator","text":"<p>               Bases: <code>BaseEstimator</code>, <code>TransformerMixin</code></p> <p>A class for generating new features based on Bayesian Network inference.</p> <p>This class constructs a Bayesian Network from input data and uses it to generate new features based on probabilistic inference.</p> <p>Attributes:</p> Name Type Description <code>known_structure</code> <code>Optional[List[Tuple[str, str]]]</code> <p>A list of edges representing the known structure of the Bayesian Network.</p> <code>bn</code> <code>Optional[BayesianNetwork]</code> <p>The constructed Bayesian Network.</p> <code>variables</code> <code>Optional[List[str]]</code> <p>List of variable names in the dataset.</p> <code>num_classes</code> <code>Optional[int]</code> <p>Number of unique classes in the target variable.</p> Source code in <code>applybn/feature_extraction/bn_feature_extractor.py</code> <pre><code>class BNFeatureGenerator(BaseEstimator, TransformerMixin):\n    \"\"\"\n    A class for generating new features based on Bayesian Network inference.\n\n    This class constructs a Bayesian Network from input data and uses it to generate\n    new features based on probabilistic inference.\n\n    Attributes:\n        known_structure (Optional[List[Tuple[str, str]]]): A list of edges representing\n            the known structure of the Bayesian Network.\n        bn (Optional[BayesianNetwork]): The constructed Bayesian Network.\n        variables (Optional[List[str]]): List of variable names in the dataset.\n        num_classes (Optional[int]): Number of unique classes in the target variable.\n    \"\"\"\n\n    def __init__(self, known_structure: Optional[List[Tuple[str, str]]] = None, random_seed: Optional[int] = None):\n\n        \"\"\"\n        Initializes the BNFeatureGenerator.\n\n        Args:\n            known_structure (Optional[List[Tuple[str, str]]]): A list of edges\n                representing the known structure of the Bayesian Network.\n        \"\"\"\n        self.known_structure = known_structure\n        self.bn: Optional[BayesianNetwork] = None\n        self.variables: Optional[List[str]] = None\n        self.num_classes: Optional[int] = None\n        self.random_seed = random_seed\n\n    def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None,\n            black_list: Optional[List[Tuple[str, str]]] = None) -&gt; 'BNFeatureGenerator':\n        \"\"\"\n        Fits the Bayesian Network to the input data.\n\n        Arguments:\n            X (pd.DataFrame): The input dataset.\n            y (Optional[pd.Series]): The target variable.\n            black_list (Optional[List[Tuple[str, str]]]): List of edges to be excluded\n                from the Bayesian Network.\n\n        Returns:\n            self: The trained instance of BNFeatureGenerator.\n\n        Raises:\n            Exception: If there's an error fitting the BayesianNetwork with known structure.\n        \"\"\"\n        if not isinstance(X, pd.DataFrame):\n            X = pd.DataFrame(X)\n\n        self.variables = X.columns.tolist()\n\n        if y is not None:\n            if not isinstance(y, pd.Series):\n                y = pd.Series(y)\n            self.num_classes = len(y.unique())\n\n        if self.known_structure:\n            self.bn = BayesianNetwork(self.known_structure)\n            try:\n                # Fit the network with known structure\n                self.bn.fit(X, estimator=BayesianEstimator)\n            except Exception as e:\n                logging.exception(f\"Error when training a Bayesian Network with a known structure: {e}\")\n                raise\n        else:\n            # If the structure is unknown, use the constructor to build it\n            constructor = self._BayesianNetworkConstructor(X, black_list, self.random_seed)\n            self.bn = constructor.construct_network()\n\n        return self\n\n    def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\"\n        Transforms input data by generating new features based on the trained Bayesian network.\n\n        Arguments:\n            X (pd.DataFrame): Input dataset for transformation.\n\n        Returns:\n            pd.DataFrame: A new DataFrame with generated features.\n\n        Raises:\n            KeyError: If a feature index is missing.\n            Exception: For any other inference error.\n        \"\"\"\n        if not isinstance(X, pd.DataFrame):\n            X = pd.DataFrame(X)\n\n        inference = VariableElimination(self.bn)\n\n        def process_feature(feature, row):\n            # Get the values of parent nodes for the current feature\n            evidence = {f: row[f] for f in self.bn.get_parents(feature) if f in row.index}\n            try:\n                # Perform probabilistic inference\n                prob = inference.query([feature], evidence=evidence)\n                return prob.values[row[feature]]\n            except KeyError:\n                return 1 / self.num_classes if self.num_classes else 0.5\n            except Exception as e:\n                logging.error(f\"Unexpected error in inference: {str(e)}\")\n                return 1 / self.num_classes if self.num_classes else 0.5\n\n        def process_row(row):\n            # Process all features for one row\n            return [process_feature(feature, row) for feature in self.variables]\n\n        # Use multithreading to speed up processing\n        with ThreadPoolExecutor() as executor:\n            results = list(executor.map(process_row, [row for _, row in X.iterrows()]))\n        # Form a DataFrame of generated features\n        return pd.DataFrame(results, columns=[f'lambda_{c}' for c in self.variables])\n\n\n    class _BayesianNetworkConstructor:\n        \"\"\"\n        An internal class for constructing a Bayesian Network.\n\n        This class implements methods for creating and modifying the structure\n        of a Bayesian Network based on the input data.\n\n        Attributes:\n            data (pd.DataFrame): The input dataset.\n            variables (List[str]): List of variable names in the dataset.\n            repository (List[Tuple[BayesianNetwork, float]]): Repository of best networks.\n            max_repository_size (int): Maximum size of the repository.\n            initial_max_arcs (int): Initial maximum number of arcs allowed.\n            black_list (Set[Tuple[str, str]]): Set of edges to be excluded from the network.\n        \"\"\"\n\n        def __init__(self, data: pd.DataFrame, black_list: Optional[List[Tuple[str, str]]] = None, random_seed: Optional[int] = None):\n            \"\"\"\n            Initializes the BayesianNetworkConstructor.\n\n            Args:\n                data (pd.DataFrame): The input dataset.\n                black_list (Optional[List[Tuple[str, str]]]): List of edges to be excluded\n                    from the Bayesian Network.\n            \"\"\"\n            self.data = data\n            self.variables = data.columns.tolist()\n            self.repository = []\n            self.max_repository_size = 10\n            self.initial_max_arcs = len(self.variables) // 2\n            self.black_list = set(black_list) if black_list is not None else set()\n            self.random_generator = random.Random(random_seed)\n\n        def is_valid_edge(self, edge: Tuple[str, str]) -&gt; bool:\n            \"\"\"\n            Checks if an edge is valid (not in the black list).\n\n            Args:\n                edge (Tuple[str, str]): The edge to check.\n\n            Returns:\n                bool: True if the edge is valid, False otherwise.\n            \"\"\"\n            return edge not in self.black_list\n\n        def create_forest_structure(self):\n            \"\"\"\n            Creates an initial forest structure for the Bayesian Network.\n\n            Returns:\n                BayesianNetwork: The initial forest structure.\n            \"\"\"\n            nodes = self.variables.copy()\n            edges = []\n            used_nodes = {nodes.pop(0)}\n            while nodes:\n                child = nodes.pop(0)\n                valid_parents = [p for p in used_nodes\n                                 if self.is_valid_edge((p, child))]\n                if valid_parents:\n                    parent = self.random_generator.choice(valid_parents)\n                    edges.append((parent, child))\n                    used_nodes.add(child)\n                else:\n                    used_nodes.add(child)\n\n            return BayesianNetwork(edges)\n\n        def calculate_network_score(self, network: BayesianNetwork, sample_data: pd.DataFrame) -&gt; float:\n            \"\"\"\n            Calculates the score of a given Bayesian Network.\n\n            Args:\n                network (BayesianNetwork): The Bayesian Network to score.\n                sample_data (pd.DataFrame): A sample of the data to use for scoring.\n\n            Returns:\n                float: The calculated score of the network.\n            \"\"\"\n            score = BicScore(data=sample_data)\n            total_score = 0\n            for node in network.nodes():\n                parents = list(network.get_parents(node))\n                # Add a penalty for model complexity\n                penalty = len(parents) * 0.1\n                total_score += score.local_score(node, parents) - penalty\n            return total_score\n\n        def modify_network(self, network, max_arcs: int) -&gt; BayesianNetwork:\n            \"\"\"\n            Modifies the given Bayesian Network by adding, deleting, or reversing edges.\n\n            Args:\n                network (BayesianNetwork): The Bayesian Network to modify.\n                max_arcs (int): The maximum number of arcs allowed in the network.\n\n            Returns:\n                BayesianNetwork: The modified Bayesian Network.\n\n            Raises:\n                ValueError: If the modification results in an invalid network structure.\n                Exception: For any unexpected errors during modification.\n            \"\"\"\n            edges = list(network.edges())\n            if not edges and self.random_generator.choice(['add', 'delete', 'reverse']) != 'add':\n                # If no edges exist, we can only add\n                return network\n            # Choose operation to perform\n            operation = self.random_generator.choice(['add', 'delete', 'reverse'])\n            new_edges = edges.copy()\n            try:\n                if operation == 'add' and len(edges) &lt; max_arcs:\n                    attempts = 0\n                    while attempts &lt; 10:\n                        node1, node2 = self.random_generator.sample(self.variables, 2)\n                        new_edge = (node1, node2)\n                        reverse_edge = (node2, node1)\n                        # Check that the edge doesn't exist and isn't blacklisted\n                        if (new_edge not in edges and reverse_edge not in edges\n                                and self.is_valid_edge(new_edge)):\n                            new_edges.append(new_edge)\n                            break\n                        attempts += 1\n                elif operation == 'delete' and edges:\n                    edge = self.random_generator.choice(edges)\n                    new_edges.remove(edge)\n                elif operation == 'reverse' and edges:\n                    edge = self.random_generator.choice(edges)\n                    reverse_edge = (edge[1], edge[0])\n                    if self.is_valid_edge(reverse_edge):\n                        new_edges.remove(edge)\n                        new_edges.append(reverse_edge)\n                # Validate the new network\n                new_network = BayesianNetwork(new_edges)\n                new_network.check_model()\n                return new_network\n            except ValueError as ve:\n                # For cycles or invalid edges\n                logging.exception(f\"Invalid edge operation: {ve}\")\n            except Exception as e:\n                # For unexpected errors\n                logging.exception(f\"Error modifying network: {e}\")\n            return network\n\n        def construct_network(self, iterations: int = 100) -&gt; BayesianNetwork:\n            \"\"\"\n            Constructs the Bayesian Network through an iterative process.\n\n            Args:\n                iterations (int): The number of iterations for network construction.\n\n            Returns:\n                 BayesianNetwork: The constructed Bayesian Network.\n            \"\"\"\n            current_network = self.create_forest_structure()\n            sample_size = max(len(self.data) // 10, 2)\n            max_arcs = self.initial_max_arcs\n            # Start with a forest structure\n            current_score = self.calculate_network_score(current_network,\n                                                         self.data.sample(n=sample_size))\n\n            for i in range(iterations):\n                # Increase sample size and maximum number of arcs every quarter of iterations\n                if i % (iterations // 4) == 0:\n                    sample_size = min(sample_size * 2, len(self.data))\n                    max_arcs = min(max_arcs + 2, len(self.variables) * 2)\n\n                sample_data = self.data.sample(n=sample_size)\n                new_network = self.modify_network(current_network, max_arcs)\n                new_score = self.calculate_network_score(new_network, sample_data)\n\n                if new_score &gt; current_score:\n                    # If the new network is better, update the current one and add to the repository\n                    current_network = new_network\n                    current_score = new_score\n                    self.repository.append((new_network, new_score))\n                    self.repository.sort(key=lambda x: x[1], reverse=True)\n                    self.repository = self.repository[:self.max_repository_size]\n                elif self.repository:\n                    # If the new network is not better, choose a network from the repository\n                    current_network, current_score = random.choice(self.repository)\n                    current_network = self.modify_network(current_network, max_arcs)\n\n            # Fit the final network on all data\n            current_network.fit(self.data, estimator=BayesianEstimator)\n            return current_network\n</code></pre>"},{"location":"api/feature_extraction/#applybn.feature_extraction.bn_feature_extractor.BNFeatureGenerator.__init__","title":"<code>__init__(known_structure=None, random_seed=None)</code>","text":"<p>Initializes the BNFeatureGenerator.</p> <p>Parameters:</p> Name Type Description Default <code>known_structure</code> <code>Optional[List[Tuple[str, str]]]</code> <p>A list of edges representing the known structure of the Bayesian Network.</p> <code>None</code> Source code in <code>applybn/feature_extraction/bn_feature_extractor.py</code> <pre><code>def __init__(self, known_structure: Optional[List[Tuple[str, str]]] = None, random_seed: Optional[int] = None):\n\n    \"\"\"\n    Initializes the BNFeatureGenerator.\n\n    Args:\n        known_structure (Optional[List[Tuple[str, str]]]): A list of edges\n            representing the known structure of the Bayesian Network.\n    \"\"\"\n    self.known_structure = known_structure\n    self.bn: Optional[BayesianNetwork] = None\n    self.variables: Optional[List[str]] = None\n    self.num_classes: Optional[int] = None\n    self.random_seed = random_seed\n</code></pre>"},{"location":"api/feature_extraction/#applybn.feature_extraction.bn_feature_extractor.BNFeatureGenerator.fit","title":"<code>fit(X, y=None, black_list=None)</code>","text":"<p>Fits the Bayesian Network to the input data.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>DataFrame</code> <p>The input dataset.</p> required <code>y</code> <code>Optional[Series]</code> <p>The target variable.</p> <code>None</code> <code>black_list</code> <code>Optional[List[Tuple[str, str]]]</code> <p>List of edges to be excluded from the Bayesian Network.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>self</code> <code>BNFeatureGenerator</code> <p>The trained instance of BNFeatureGenerator.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If there's an error fitting the BayesianNetwork with known structure.</p> Source code in <code>applybn/feature_extraction/bn_feature_extractor.py</code> <pre><code>def fit(self, X: pd.DataFrame, y: Optional[pd.Series] = None,\n        black_list: Optional[List[Tuple[str, str]]] = None) -&gt; 'BNFeatureGenerator':\n    \"\"\"\n    Fits the Bayesian Network to the input data.\n\n    Arguments:\n        X (pd.DataFrame): The input dataset.\n        y (Optional[pd.Series]): The target variable.\n        black_list (Optional[List[Tuple[str, str]]]): List of edges to be excluded\n            from the Bayesian Network.\n\n    Returns:\n        self: The trained instance of BNFeatureGenerator.\n\n    Raises:\n        Exception: If there's an error fitting the BayesianNetwork with known structure.\n    \"\"\"\n    if not isinstance(X, pd.DataFrame):\n        X = pd.DataFrame(X)\n\n    self.variables = X.columns.tolist()\n\n    if y is not None:\n        if not isinstance(y, pd.Series):\n            y = pd.Series(y)\n        self.num_classes = len(y.unique())\n\n    if self.known_structure:\n        self.bn = BayesianNetwork(self.known_structure)\n        try:\n            # Fit the network with known structure\n            self.bn.fit(X, estimator=BayesianEstimator)\n        except Exception as e:\n            logging.exception(f\"Error when training a Bayesian Network with a known structure: {e}\")\n            raise\n    else:\n        # If the structure is unknown, use the constructor to build it\n        constructor = self._BayesianNetworkConstructor(X, black_list, self.random_seed)\n        self.bn = constructor.construct_network()\n\n    return self\n</code></pre>"},{"location":"api/feature_extraction/#applybn.feature_extraction.bn_feature_extractor.BNFeatureGenerator.transform","title":"<code>transform(X)</code>","text":"<p>Transforms input data by generating new features based on the trained Bayesian network.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>DataFrame</code> <p>Input dataset for transformation.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A new DataFrame with generated features.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If a feature index is missing.</p> <code>Exception</code> <p>For any other inference error.</p> Source code in <code>applybn/feature_extraction/bn_feature_extractor.py</code> <pre><code>def transform(self, X: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Transforms input data by generating new features based on the trained Bayesian network.\n\n    Arguments:\n        X (pd.DataFrame): Input dataset for transformation.\n\n    Returns:\n        pd.DataFrame: A new DataFrame with generated features.\n\n    Raises:\n        KeyError: If a feature index is missing.\n        Exception: For any other inference error.\n    \"\"\"\n    if not isinstance(X, pd.DataFrame):\n        X = pd.DataFrame(X)\n\n    inference = VariableElimination(self.bn)\n\n    def process_feature(feature, row):\n        # Get the values of parent nodes for the current feature\n        evidence = {f: row[f] for f in self.bn.get_parents(feature) if f in row.index}\n        try:\n            # Perform probabilistic inference\n            prob = inference.query([feature], evidence=evidence)\n            return prob.values[row[feature]]\n        except KeyError:\n            return 1 / self.num_classes if self.num_classes else 0.5\n        except Exception as e:\n            logging.error(f\"Unexpected error in inference: {str(e)}\")\n            return 1 / self.num_classes if self.num_classes else 0.5\n\n    def process_row(row):\n        # Process all features for one row\n        return [process_feature(feature, row) for feature in self.variables]\n\n    # Use multithreading to speed up processing\n    with ThreadPoolExecutor() as executor:\n        results = list(executor.map(process_row, [row for _, row in X.iterrows()]))\n    # Form a DataFrame of generated features\n    return pd.DataFrame(results, columns=[f'lambda_{c}' for c in self.variables])\n</code></pre>"},{"location":"api/feature_extraction/#example","title":"Example","text":"<pre><code>from applybn.feature_extraction import BNFeatureGenerator\nimport pandas as pd\n\ndata = pd.read_csv('your_data.csv')\n\ngenerator = BNFeatureGenerator()\ngenerator.fit(data)\n\nnew_features = generator.transform(data)\ndata_combined = pd.concat([data, new_features], axis=1)\n</code></pre>"},{"location":"api/feature_selection/","title":"Feature Selection","text":""},{"location":"api/feature_selection/#bnfeatureselector","title":"BNFeatureSelector","text":"<p>               Bases: <code>BaseEstimator</code>, <code>SelectorMixin</code></p> <p>Bayesian Network feature selector.</p> Source code in <code>applybn/feature_selection/bn_feature_selector.py</code> <pre><code>class BNFeatureSelector(BaseEstimator, SelectorMixin):\n    \"\"\"Bayesian Network feature selector.\"\"\"\n\n    # TODO: Implement Bayesian Network feature selector, use SelectorMixin as reference\n    def fit(self, X, y=None):\n        self.n_features_in_ = X.shape[1]\n        return self\n\n    def _get_support_mask(self):\n        mask = np.zeros(self.n_features_in_, dtype=bool)\n        mask[:2] = True\n        return mask\n</code></pre>"},{"location":"api/feature_selection/#causalfeatureselector","title":"CausalFeatureSelector","text":"<p>               Bases: <code>BaseEstimator</code>, <code>SelectorMixin</code></p> Source code in <code>applybn/feature_selection/ce_feature_selector.py</code> <pre><code>class CausalFeatureSelector(BaseEstimator, SelectorMixin):\n    def __init__(self, n_bins: Union[int, str] = 'auto'):\n        \"\"\"\n        Initialize the causal feature selector.\n\n        Args:\n            n_bins: Number of bins for discretization or 'auto' for automatic selection.\n        \"\"\"\n        self.n_bins = n_bins\n\n    def fit(self, X: np.ndarray, y: np.ndarray) -&gt; 'CausalFeatureSelector':\n        \"\"\"\n        Fit the causal feature selector to the data.\n\n        Args:\n            X: Feature matrix (2D array).\n            y: Target variable (1D array).\n\n        Returns:\n            self\n        \"\"\"\n        # Validate inputs\n        X, y = check_X_y(X, y)\n        self.X_ = X\n        self.y_ = y\n\n        # Compute the support mask for selected features\n        self.support_ = self._select_features(X, y)\n        return self\n\n    def _select_features(self, data: np.ndarray, target: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Core logic for selecting features based on causal influence.\n\n        Args:\n            data: Feature matrix.\n            target: Target variable.\n\n        Returns:\n            Boolean mask of selected features.\n        \"\"\"\n        # Discretize target and features\n        target_discretized = self._discretize_data_iqr(target)[0]\n        data_discretized = np.array([self._discretize_data_iqr(data[:, i])[0] for i in range(data.shape[1])]).T\n\n        selected_mask = np.zeros(data.shape[1], dtype=bool)\n        other_features = np.array([])\n\n        for i in range(data.shape[1]):\n            feature = data[:, i]\n            # Compute causal effect of the current feature\n            ce = self._causal_effect(feature, target, other_features)\n\n            if ce &gt; 0:  # If causal effect is significant\n                selected_mask[i] = True\n                if other_features.size &gt; 0:\n                    other_features = np.c_[other_features, feature]\n                else:\n                    other_features = feature.reshape(-1, 1)\n\n        return selected_mask\n\n    def _get_support_mask(self) -&gt; np.ndarray:\n        \"\"\"\n        Required by SelectorMixin to return the mask of selected features.\n\n        Returns:\n            Boolean mask of selected features.\n        \"\"\"\n        return self.support_\n\n    def _discretize_data_iqr(self, data: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Discretize data using the interquartile range (IQR) rule.\n\n        Args:\n            data: Data to discretize.\n\n        Returns:\n            Discretized data and bin edges.\n        \"\"\"\n        # Compute range and IQR\n        R = np.ptp(data)\n        iqr = np.subtract(*np.percentile(data, [75, 25]))\n        iqr = max(iqr, 1e-8)  # Avoid division by zero\n\n        n = len(data)\n        # Determine the number of bins\n        n_bins = self.n_bins if self.n_bins != 'auto' else max(2, int(np.ceil((R / (2 * iqr * n ** (1/3))) * np.log2(n + 1))))\n\n        bins = np.linspace(np.min(data), np.max(data), n_bins + 1)\n        discretized_data = np.digitize(data, bins) - 1\n        discretized_data = np.clip(discretized_data, 0, len(bins) - 2)\n\n        return discretized_data, bins\n\n    def _causal_effect(self, Xi: np.ndarray, Y: np.ndarray, other_features: np.ndarray) -&gt; float:\n        \"\"\"\n        Compute the causal effect of Xi on Y, controlling for other features.\n\n        Args:\n            Xi: Feature for which the causal effect is calculated.\n            Y: Target variable.\n            other_features: Matrix of other features to control for.\n\n        Returns:\n            Causal effect of Xi on Y.\n        \"\"\"\n        Y_discretized = self._discretize_data_iqr(Y)[0]\n        Xi_discretized = self._discretize_data_iqr(Xi)[0]\n\n        if other_features.size &gt; 0:\n            # Discretize other features if they exist\n            other_features_discretized = np.array([self._discretize_data_iqr(other_features[:, i])[0] for i in range(other_features.shape[1])]).T\n            combined_features = np.c_[other_features_discretized, Xi_discretized]\n            H_Y_given_other = self._conditional_entropy(other_features_discretized, Y_discretized)\n            H_Y_given_Xi_other = self._conditional_entropy(combined_features, Y_discretized)\n            return H_Y_given_other - H_Y_given_Xi_other\n        else:\n            return self._entropy(Y_discretized) - self._conditional_entropy(Xi_discretized, Y_discretized)\n\n    def _entropy(self, discretized_data: np.ndarray) -&gt; float:\n        \"\"\"\n        Compute the entropy of discretized data.\n\n        Args:\n            discretized_data: Discretized data.\n\n        Returns:\n            Entropy of the data.\n        \"\"\"\n        value_counts = np.unique(discretized_data, return_counts=True)[1]\n        probabilities = value_counts / len(discretized_data)\n        return -np.sum(probabilities[probabilities &gt; 0] * np.log2(probabilities[probabilities &gt; 0]))\n\n    def _conditional_entropy(self, X: np.ndarray, Y: np.ndarray) -&gt; float:\n        \"\"\"\n        Compute the conditional entropy H(Y|X).\n\n        Args:\n            X: Discretized features.\n            Y: Discretized target variable.\n\n        Returns:\n            Conditional entropy H(Y|X).\n        \"\"\"\n        unique_x = np.unique(X, axis=0)\n        cond_entropy = 0\n\n        for x in unique_x:\n            # Mask for rows where X equals the current unique value\n            if X.ndim == 1:\n                mask = (X == x)  # Simple comparison for 1D array\n            else:\n                mask = np.all(X == x, axis=1)\n            subset_entropy = self._entropy(Y[mask])\n            cond_entropy += np.sum(mask) / len(X) * subset_entropy\n\n        return cond_entropy\n</code></pre> <pre><code>import pandas as pd\nfrom applybn.feature_selection.ce_feature_selector import CausalFeatureSelector\n\ndf = pd.read_csv('datat.csv') \ntarget = df['target']\n\nfeatures = df.drop(columns=['target'])\nselector = CausalFeatureSelector(n_bins='auto')\nselector.fit(features.values, target.values)\n\nprint(selector.transform(features.values))\n</code></pre>"},{"location":"api/feature_selection/#applybn.feature_selection.ce_feature_selector.CausalFeatureSelector.__init__","title":"<code>__init__(n_bins='auto')</code>","text":"<p>Initialize the causal feature selector.</p> <p>Parameters:</p> Name Type Description Default <code>n_bins</code> <code>Union[int, str]</code> <p>Number of bins for discretization or 'auto' for automatic selection.</p> <code>'auto'</code> Source code in <code>applybn/feature_selection/ce_feature_selector.py</code> <pre><code>def __init__(self, n_bins: Union[int, str] = 'auto'):\n    \"\"\"\n    Initialize the causal feature selector.\n\n    Args:\n        n_bins: Number of bins for discretization or 'auto' for automatic selection.\n    \"\"\"\n    self.n_bins = n_bins\n</code></pre>"},{"location":"api/feature_selection/#applybn.feature_selection.ce_feature_selector.CausalFeatureSelector.fit","title":"<code>fit(X, y)</code>","text":"<p>Fit the causal feature selector to the data.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Feature matrix (2D array).</p> required <code>y</code> <code>ndarray</code> <p>Target variable (1D array).</p> required <p>Returns:</p> Type Description <code>CausalFeatureSelector</code> <p>self</p> Source code in <code>applybn/feature_selection/ce_feature_selector.py</code> <pre><code>def fit(self, X: np.ndarray, y: np.ndarray) -&gt; 'CausalFeatureSelector':\n    \"\"\"\n    Fit the causal feature selector to the data.\n\n    Args:\n        X: Feature matrix (2D array).\n        y: Target variable (1D array).\n\n    Returns:\n        self\n    \"\"\"\n    # Validate inputs\n    X, y = check_X_y(X, y)\n    self.X_ = X\n    self.y_ = y\n\n    # Compute the support mask for selected features\n    self.support_ = self._select_features(X, y)\n    return self\n</code></pre>"},{"location":"api/pipeline_creation/","title":"Pipeline creation","text":"<p>High-level Pipeline creator.</p> Source code in <code>applybn/pipeline_creator.py</code> <pre><code>class PipelineCreator:\n    \"\"\"High-level Pipeline creator.\"\"\"\n\n    def __init__(self, config):\n        self.config = config\n        self.pipeline = None\n\n    def run(self):\n        # Placeholder for pipeline running logic\n        return None\n\n    def _load_data(self, file_path):\n        # Placeholder for data loading logic\n        return None\n\n    def _preprocess_data(self, data, params):\n        # Placeholder for data preprocessing logic\n        return data\n\n    def _detect_outliers(self, data, params):\n        # Placeholder for outlier detection logic\n        return data\n\n    def _explain_model(self, data, params):\n        # Placeholder for model explanation logic\n        return None\n\n    def _validate_model(self, data):\n        # Placeholder for model validation logic\n        return None\n</code></pre>"},{"location":"api/synthetic_data_generation/","title":"Synthetic Data Generation","text":"<p>Bayesian Network Synthetic Data Generator.</p> Source code in <code>applybn/synthetics/bn_synthetic_generator.py</code> <pre><code>class BNSyntheticGenerator:\n    \"\"\"Bayesian Network Synthetic Data Generator.\"\"\"\n\n    def __init__(self):\n        pass\n\n    def fit(self, data):\n        \"\"\"\n        Fit the Bayesian Network model to the data.\n\n        Parameters:\n        data (pd.DataFrame): The input data to fit the model.\n        \"\"\"\n        # Placeholder for fitting logic\n        pass\n\n    def sample(self, num_samples):\n        \"\"\"\n        Generate synthetic samples from the fitted Bayesian Network model.\n\n        Parameters:\n        num_samples (int): The number of synthetic samples to generate.\n\n        Returns:\n        pd.DataFrame: The generated synthetic samples.\n        \"\"\"\n        # Placeholder for sampling logic\n        return None\n\n    def save(self, filepath):\n        \"\"\"\n        Save the fitted model to a file.\n\n        Parameters:\n        filepath (str): The path to save the model.\n        \"\"\"\n        # Placeholder for save logic\n        pass\n\n    def load(self, filepath):\n        \"\"\"\n        Load a fitted model from a file.\n\n        Parameters:\n        filepath (str): The path to load the model from.\n        \"\"\"\n        # Placeholder for load logic\n        pass\n</code></pre>"},{"location":"api/synthetic_data_generation/#applybn.synthetics.bn_synthetic_generator.BNSyntheticGenerator.fit","title":"<code>fit(data)</code>","text":"<p>Fit the Bayesian Network model to the data.</p> <p>Parameters: data (pd.DataFrame): The input data to fit the model.</p> Source code in <code>applybn/synthetics/bn_synthetic_generator.py</code> <pre><code>def fit(self, data):\n    \"\"\"\n    Fit the Bayesian Network model to the data.\n\n    Parameters:\n    data (pd.DataFrame): The input data to fit the model.\n    \"\"\"\n    # Placeholder for fitting logic\n    pass\n</code></pre>"},{"location":"api/synthetic_data_generation/#applybn.synthetics.bn_synthetic_generator.BNSyntheticGenerator.load","title":"<code>load(filepath)</code>","text":"<p>Load a fitted model from a file.</p> <p>Parameters: filepath (str): The path to load the model from.</p> Source code in <code>applybn/synthetics/bn_synthetic_generator.py</code> <pre><code>def load(self, filepath):\n    \"\"\"\n    Load a fitted model from a file.\n\n    Parameters:\n    filepath (str): The path to load the model from.\n    \"\"\"\n    # Placeholder for load logic\n    pass\n</code></pre>"},{"location":"api/synthetic_data_generation/#applybn.synthetics.bn_synthetic_generator.BNSyntheticGenerator.sample","title":"<code>sample(num_samples)</code>","text":"<p>Generate synthetic samples from the fitted Bayesian Network model.</p> <p>Parameters: num_samples (int): The number of synthetic samples to generate.</p> <p>Returns: pd.DataFrame: The generated synthetic samples.</p> Source code in <code>applybn/synthetics/bn_synthetic_generator.py</code> <pre><code>def sample(self, num_samples):\n    \"\"\"\n    Generate synthetic samples from the fitted Bayesian Network model.\n\n    Parameters:\n    num_samples (int): The number of synthetic samples to generate.\n\n    Returns:\n    pd.DataFrame: The generated synthetic samples.\n    \"\"\"\n    # Placeholder for sampling logic\n    return None\n</code></pre>"},{"location":"api/synthetic_data_generation/#applybn.synthetics.bn_synthetic_generator.BNSyntheticGenerator.save","title":"<code>save(filepath)</code>","text":"<p>Save the fitted model to a file.</p> <p>Parameters: filepath (str): The path to save the model.</p> Source code in <code>applybn/synthetics/bn_synthetic_generator.py</code> <pre><code>def save(self, filepath):\n    \"\"\"\n    Save the fitted model to a file.\n\n    Parameters:\n    filepath (str): The path to save the model.\n    \"\"\"\n    # Placeholder for save logic\n    pass\n</code></pre>"},{"location":"api/core/core/","title":"Core","text":""},{"location":"api/core/logger/","title":"Logger","text":"<p>A logger class using rich and logging libraries.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the logger.</p> <code>level</code> <code>int</code> <p>Logging level (e.g., logging.DEBUG, logging.INFO).</p> <code>log_file</code> <code>str</code> <p>Path to a file to log messages. If None, logs will not be saved to a file.</p> <code>logger</code> <code>Logger</code> <p>Configured logger instance.</p> <p>Methods:</p> Name Description <code>get_logger</code> <p>Returns the configured logger instance.</p> Usage Examples Source code in <code>applybn/core/logger.py</code> <pre><code>class Logger:\n    \"\"\"\n    A logger class using rich and logging libraries.\n\n    Attributes:\n        name (str): Name of the logger.\n        level (int): Logging level (e.g., logging.DEBUG, logging.INFO).\n        log_file (str, optional): Path to a file to log messages. If None, logs will not be saved to a file.\n        logger (logging.Logger): Configured logger instance.\n\n    Methods:\n        get_logger(): Returns the configured logger instance.\n\n    Usage Examples:\n        # Basic setup\n        &gt;&gt;&gt; logger = Logger(\"my_logger\", level=logging.DEBUG)\n        &gt;&gt;&gt; log = logger.get_logger()\n        &gt;&gt;&gt; log.info(\"This is an info message\")\n        &gt;&gt;&gt; log.debug(\"This is a debug message\")\n\n        # Setup with file logging\n        &gt;&gt;&gt; logger = Logger(\"file_logger\", level=logging.INFO, log_file=\"my_log.log\")\n        &gt;&gt;&gt; log = logger.get_logger()\n        &gt;&gt;&gt; log.info(\"This will be logged to the file\")\n    \"\"\"\n\n    def __init__(self, name, level=logging.INFO, log_file=None):\n        \"\"\"\n        Initializes the Logger with a specified name, level, and optional log file.\n\n        Parameters:\n            name (str): Name of the logger.\n            level (int): Logging level (e.g., logging.DEBUG, logging.INFO).\n            log_file (str, optional): Path to a file to log messages. If None, logs will not be saved to a file.\n        \"\"\"\n        self.name = name\n        self.level = level\n        self.log_file = log_file\n        self.logger = self._setup_logger()\n\n    def _setup_logger(self):\n        \"\"\"\n        Sets up the logger with rich and logging libraries.\n\n        Returns:\n            logging.Logger: Configured logger instance.\n        \"\"\"\n        logger = logging.getLogger(self.name)\n        logger.setLevel(self.level)\n\n        # Create a console handler using RichHandler\n        console_handler = RichHandler()\n        console_handler.setLevel(self.level)\n\n        # Create a formatter and set it for the console handler\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        console_handler.setFormatter(formatter)\n\n        # Add the console handler to the logger\n        if not logger.handlers:\n            logger.addHandler(console_handler)\n\n        # Optionally add a file handler if log_file is specified\n        if self.log_file:\n            file_handler = logging.FileHandler(self.log_file)\n            file_handler.setLevel(self.level)\n            file_handler.setFormatter(formatter)\n            logger.addHandler(file_handler)\n\n        return logger\n\n    def get_logger(self):\n        \"\"\"\n        Returns the configured logger instance.\n\n        Returns:\n            logging.Logger: Configured logger instance.\n        \"\"\"\n        return self.logger\n</code></pre>"},{"location":"api/core/logger/#applybn.core.logger.Logger--basic-setup","title":"Basic setup","text":"<p>logger = Logger(\"my_logger\", level=logging.DEBUG) log = logger.get_logger() log.info(\"This is an info message\") log.debug(\"This is a debug message\")</p>"},{"location":"api/core/logger/#applybn.core.logger.Logger--setup-with-file-logging","title":"Setup with file logging","text":"<p>logger = Logger(\"file_logger\", level=logging.INFO, log_file=\"my_log.log\") log = logger.get_logger() log.info(\"This will be logged to the file\")</p>"},{"location":"api/core/logger/#applybn.core.logger.Logger.__init__","title":"<code>__init__(name, level=logging.INFO, log_file=None)</code>","text":"<p>Initializes the Logger with a specified name, level, and optional log file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the logger.</p> required <code>level</code> <code>int</code> <p>Logging level (e.g., logging.DEBUG, logging.INFO).</p> <code>INFO</code> <code>log_file</code> <code>str</code> <p>Path to a file to log messages. If None, logs will not be saved to a file.</p> <code>None</code> Source code in <code>applybn/core/logger.py</code> <pre><code>def __init__(self, name, level=logging.INFO, log_file=None):\n    \"\"\"\n    Initializes the Logger with a specified name, level, and optional log file.\n\n    Parameters:\n        name (str): Name of the logger.\n        level (int): Logging level (e.g., logging.DEBUG, logging.INFO).\n        log_file (str, optional): Path to a file to log messages. If None, logs will not be saved to a file.\n    \"\"\"\n    self.name = name\n    self.level = level\n    self.log_file = log_file\n    self.logger = self._setup_logger()\n</code></pre>"},{"location":"api/core/logger/#applybn.core.logger.Logger.get_logger","title":"<code>get_logger()</code>","text":"<p>Returns the configured logger instance.</p> <p>Returns:</p> Type Description <p>logging.Logger: Configured logger instance.</p> Source code in <code>applybn/core/logger.py</code> <pre><code>def get_logger(self):\n    \"\"\"\n    Returns the configured logger instance.\n\n    Returns:\n        logging.Logger: Configured logger instance.\n    \"\"\"\n    return self.logger\n</code></pre>"},{"location":"api/outlier_detection/outlier_detection/","title":"Outlier Detection","text":""},{"location":"api/outlier_detection/tabular_outliers/","title":"Tabular Outlier Detection","text":"<p>               Bases: <code>BaseEstimator</code>, <code>OutlierMixin</code></p> <p>Bayesian Network outlier detector.</p> Source code in <code>applybn/outlier_detection/tabular/bn_outlier_detector.py</code> <pre><code>class BNOutlierDetector(BaseEstimator, OutlierMixin):\n    \"\"\"Bayesian Network outlier detector.\"\"\"\n\n    # TODO: Implement Bayesian Network outlier detector using OutlierMixin as reference\n    def __init__(self):\n        pass\n\n    def fit(self, X, y=None):\n        # Placeholder fitting logic\n        return self\n\n    def predict(self, X):\n        # Return -1 for outliers, 1 for inliers\n        return np.ones(X.shape[0])\n\n    def decision_function(self, X):\n        return np.zeros(X.shape[0])\n</code></pre>"},{"location":"api/outlier_detection/ts_outliers/","title":"Time Series Outlier Detection","text":"<p>               Bases: <code>BaseEstimator</code></p> <p>Bayesian Network timeseries outlier detector.</p> Source code in <code>applybn/outlier_detection/timeseries/bn_ts_outlier_detector.py</code> <pre><code>class BNTSOutlierDetector(BaseEstimator):\n    \"\"\"Bayesian Network timeseries outlier detector.\"\"\"\n\n    def __init__(self):\n        pass\n\n    def fit(self, X, y=None):\n        # Placeholder for timeseries-based logic\n        return self\n\n    def predict(self, X):\n        # Return -1 for outliers, 1 for inliers\n        return np.ones(X.shape[0])\n</code></pre>"},{"location":"development/contributing/","title":"How to contribute","text":""},{"location":"development/contributing/#fast-checklist","title":"Fast Checklist","text":"<ul> <li> Fork the repository</li> <li> Clone the repository</li> <li> Create a new branch</li> <li> Ensure sklearn compatibility</li> <li> Write or update documentation with usage examples</li> <li> Check documentation with serve</li> <li> Write unittests</li> <li> Run tests to ensure everything works</li> <li> Commit your changes</li> <li> Push your branch</li> <li> Open a pull request</li> </ul>"},{"location":"development/contributing/#contribution-guide","title":"Contribution Guide","text":"<p>We welcome contributions to the project. To contribute, please follow these steps:</p> <ol> <li> <p>Cloning the repository</p> <ul> <li>Fork the repository to your GitHub account.</li> <li>Clone your forked repository to your local machine using the following command:   <pre><code>git clone https://github.com/Anaxagor/applyBN.git\n</code></pre></li> <li>Navigate to the project directory:   <pre><code>cd applyBN\n</code></pre></li> </ul> </li> <li> <p>Creating a branch</p> <ul> <li>Create a new branch for your feature or bug fix:   <pre><code>git checkout -b your-branch-name\n</code></pre></li> </ul> </li> <li> <p>Keeping everything sklearn-compatible</p> <ul> <li>Ensure that your contributions are compatible with <code>scikit-learn</code> where applicable. This includes following their conventions, inheriting their classes and ensuring interoperability.</li> </ul> </li> <li> <p>Writing documentation with usage example</p> <ul> <li>We use <code>mkdocs</code> for documentation. Add or update documentation in the <code>docs</code> directory.</li> <li>Include usage examples to demonstrate how to use your feature or changes.</li> <li>To preview the documentation locally, run:   <pre><code>mkdocs serve\n</code></pre></li> </ul> </li> <li> <p>Writing unittests</p> <ul> <li>Write unittests for your code to ensure its correctness.</li> <li>Place your tests in the <code>tests</code> directory.</li> <li>Run the tests to make sure everything works:   <pre><code>pytest -s tests\n</code></pre></li> </ul> </li> <li> <p>Submitting your changes</p> <ul> <li>Commit your changes with a descriptive commit message:   <pre><code>git commit -m \"Description of your changes\"\n</code></pre></li> <li>Push your branch to your forked repository:   <pre><code>git push origin your-branch-name\n</code></pre></li> <li>Open a pull request on the original repository and provide a detailed description of your changes.</li> </ul> </li> </ol> <p>Thank you for your contributions!</p>"},{"location":"examples/pipeline_creation/","title":"Pipeline Creation","text":""},{"location":"examples/synthetic_data_generation/","title":"Synthetic Data Generation","text":""},{"location":"examples/tabular_data/","title":"Tabular Data","text":""},{"location":"examples/time_series_data/","title":"Time series Data","text":""}]}